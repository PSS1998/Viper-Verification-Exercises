// Viper Code for Circular Buffer and Linked List

field cb_contents: Ref
field head: Int
field tail: Int
field ghost_content2: Seq[Int]

// Array API (Provided)
predicate array(self: Ref)
function array_len(self: Ref): Int
    requires array(self)
function array_read(self: Ref, idx: Int): Int
    requires array(self)
    requires 0 <= idx && idx < array_len(self)
method array_write(self: Ref, idx: Int, val: Int)
    requires array(self)
    requires 0 <= idx && idx < array_len(self)
    ensures array(self)
    ensures array_len(self) == old(array_len(self))
    ensures forall i: Int :: {array_read(self, i)} 0 <= i && i < array_len(self) && i != idx ==>
        array_read(self, i) == old(array_read(self, i))
    ensures array_read(self, idx) == val


// Part 1: Circular Buffer Predicate
predicate cb(buf: Ref, ghost_content: Seq[Int])
{
    acc(buf.ghost_content2) &&
    acc(buf.head) && acc(buf.tail) && acc(buf.cb_contents) && array(buf.cb_contents) && 
    array_len(buf.cb_contents) > 0 &&
    0 <= buf.head && 
    0 <= buf.tail && 
    buf.tail < array_len(buf.cb_contents) && 
    buf.head < array_len(buf.cb_contents) &&
    |buf.ghost_content2| == (buf.tail - buf.head) % array_len(buf.cb_contents) &&
    |buf.ghost_content2| < array_len(buf.cb_contents) &&
    |buf.ghost_content2| >= 0 &&
    (forall i: Int :: (0 <= i) && (i < |buf.ghost_content2|) &&
        (buf.head + i < array_len(buf.cb_contents)) ==>
        (buf.ghost_content2[i] == array_read(buf.cb_contents, (i+buf.head)))) &&
    (forall j: Int :: (0 <= j) && (j < |buf.ghost_content2|) &&
        (buf.head + j >= array_len(buf.cb_contents)) ==>
        (buf.ghost_content2[j] == array_read(buf.cb_contents, buf.head + j - array_len(buf.cb_contents))))
}

function math_reverse(sequence: Seq[Int]): Seq[Int] 
{
    sequence == Seq[Int]() ? Seq[Int]() : math_reverse(sequence[1..])++Seq(sequence[0])
}

function cb_empty(buf: Ref, ghost_content: Seq[Int]): Bool 
    requires cb(buf, ghost_content)
{
    unfolding cb(buf, ghost_content) in buf.tail != buf.head ? false : true
}

function cb_has_room(buf: Ref, ghost_content: Seq[Int]): Bool 
    requires cb(buf, ghost_content)
{
    unfolding cb(buf, ghost_content) in ((buf.tail - buf.head) % array_len(buf.cb_contents)) < array_len(buf.cb_contents) - 1
}

function cb_length(buf: Ref, ghost_content: Seq[Int]): Int
    requires cb(buf, ghost_content)
{
    unfolding cb(buf, ghost_content) in (buf.tail - buf.head) % array_len(buf.cb_contents)
}

function get_ghost_content(buf: Ref, ghost_content: Seq[Int]): Seq[Int]
    requires cb(buf, ghost_content)
{
    unfolding cb(buf, ghost_content) in buf.ghost_content2
}

// Part 2.1: Read Method
method cb_read(buf: Ref, ghost_content: Seq[Int]) returns (res: Int)
    requires cb(buf, ghost_content)
    requires unfolding cb(buf, ghost_content) in buf.tail != buf.head
    requires unfolding cb(buf, ghost_content) in |buf.ghost_content2| > 0
    ensures res == old(get_ghost_content(buf, ghost_content)[0])
    ensures cb(buf, ghost_content)
    // ensures cb_length(buf, ghost_content) == old(cb_length(buf, ghost_content)) - 1
{
    unfold cb(buf, ghost_content)
    res := array_read(buf.cb_contents, (buf.head))
    buf.head := ((buf.head + 1) < array_len(buf.cb_contents)) ? (buf.head + 1) : 0
    buf.ghost_content2 := buf.ghost_content2[1..]
    fold cb(buf, ghost_content)
}

// Part 2.2: Write Method
method cb_write(buf: Ref, val: Int, ghost_content: Seq[Int])
    requires cb(buf, ghost_content)
    requires unfolding cb(buf, ghost_content) in ((buf.tail - buf.head) % array_len(buf.cb_contents)) < array_len(buf.cb_contents) - 1
    requires unfolding cb(buf, ghost_content) in |buf.ghost_content2| < array_len(buf.cb_contents) - 1
    // ensures cb_length(buf, ghost_content) == old(cb_length(buf, ghost_content)) + 1
    ensures cb(buf, ghost_content)    
{
    unfold cb(buf, ghost_content)
    array_write(buf.cb_contents, buf.tail, val)

    buf.tail := ((buf.tail + 1) < array_len(buf.cb_contents)) ? (buf.tail + 1) : 0

    buf.ghost_content2 := buf.ghost_content2 ++ Seq(val)

    fold cb(buf, ghost_content)
}

field next: Ref
field elem: Int

// Part 3: Linked List
predicate list(this: Ref) {
    acc(this.elem) && acc(this.next) && 
    (this.next != null ==> list(this.next))
}

method create_list() returns (res: Ref)
    ensures  list(res)
{
    res := new(*)
    res.next := null
    fold list(res)
}

method prepend_list(this: Ref, e: Int) returns (res: Ref)
    requires list(this)
    ensures  list(res)
{
    res := new(*)
    res.elem := e
    res.next := this
    fold list(res)
}

method head_list(this: Ref) returns (res: Int)
  requires list(this)
  ensures  list(this)
{
    unfold list(this)
    res := this.elem
    fold list(this)
}

// function get_reverse_content(buf: Ref, ghost_content: Seq[Int]): Seq[Int]
//     requires cb(buf, ghost_content)
// {
//     unfolding cb(buf, ghost_content) in reverse_content(buf.cb_contents, (buf.head + 1) % array_len(buf.cb_contents), buf.head)
// }

// Part 4: Method to reverse Circular Buffer
method cb_reverse(buf: Ref, ghost_content: Seq[Int], rev_content: Seq[Int])
    requires cb(buf, ghost_content)
    ensures cb(buf, ghost_content)
    // ensures get_ghost_content(buf, ghost_content) == old(math_reverse(get_ghost_content(buf, ghost_content)))
{
    var e: Int
    var linked_list: Ref
    
    linked_list := create_list()

    var array_length: Int := cb_length(buf, ghost_content)

    var index: Int := 0
    while (!cb_empty(buf, ghost_content)) 
        invariant cb(buf, ghost_content)
        invariant list(linked_list)
        // invariant !cb_empty(buf, ghost_content) ==> cb_length(buf, ghost_content) + index == array_length
    {
        e := cb_read(buf, ghost_content)
        linked_list := prepend_list(linked_list, e)
        index := index + 1
    }

    var index2: Int := 0
    while (linked_list != null) 
        invariant cb(buf, ghost_content)
        invariant (linked_list != null) ==> list(linked_list)
        // invariant cb_length(buf, ghost_content) <= array_length
        // invariant index2 <= array_length
        // invariant old(get_ghost_content(buf, ghost_content)[cb_length(buf, ghost_content) - index2]) == get_ghost_content(buf, ghost_content)[index2]
        // invariant cb_length(buf, ghost_content) + linked_list_lenght(linked_list) == array_length
    {
        e := head_list(linked_list)
        if (cb_has_room(buf, ghost_content)) {
            cb_write(buf, e, ghost_content)
        }
        unfold list(linked_list)
        linked_list := linked_list.next
        index2 := index2 + 1
    }

}
