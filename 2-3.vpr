predicate time_credit()
method consume_time_credit()
    requires time_credit()

function array_offset(base: Ref, idx: Int): Ref



/* 
 * Encoding of integer arrays 
 * can be used in other Viper files in the same directory via import "ArrayPrelude.vpr"
 */
field value: Int // for integer arrays
domain Array {
    function loc(a: Array, i: Int): Ref
    function len(a: Array): Int
    function first(r: Ref): Array
    function second(r: Ref): Int

    axiom injectivity {
        forall a: Array, i: Int :: {loc(a, i)}
        first(loc(a, i)) == a && second(loc(a, i)) == i
    }

    axiom length_nonneg {
        forall a: Array :: len(a) >= 0
    }
}

define lookup(a, i) 
    loc(a, i).value

define update(a, i, e) {
    loc(a, i).value := e
}

define array(a)
    (forall i: Int :: {loc(a, i)}  0 <= i && i < len(a) ==> acc(loc(a, i).value)) 

define arraySeg(a, f, t)
    (forall i: Int :: {loc(a, i)}  f <= i && i < t && i < len(a) ==> acc(loc(a, i).value)) 

define alloc(a, l) {
    inhale array(a) && len(a) == l
}


function get_content_dyn_arr(this: Ref): Seq[Int]
    requires dyn_array(this)
    // ensures unfolding dyn_array(this) in |result| == this.length
    // ensures unfolding dyn_array(this) in forall i:Int :: 0 <= i && i < this.length ==> get_content(this.content, 0, this.length)[i] == lookup(this.content, i)
{
    unfolding dyn_array(this) in get_content(this.content, 0, this.length)
}

function get_content(this: Array, i: Int, size: Int): Seq[Int]
    requires array(this)
    requires size <= len(this)
    requires i >= 0
    requires i <= size
    requires |Seq[Int]()| == 0
    ensures (i <= size) ==> (|result| == size - i)
{
    (i >= size ? Seq[Int]() : Seq(lookup(this, i)) ++ get_content(this, i+1, size))
}


field content: Array
field capacity: Int
field length: Int
// PART 1: Dynamic array predicate
//
// Define a predicate for a dynamic array. You may define new fields. You may
// add arguments or heap-based functions for abstraction.
predicate dyn_array(this: Ref) {
    acc(this.content) && acc(this.capacity) && acc(this.length) && 
    array(this.content) && len(this.content) == this.capacity &&
    this.length >= 0 && this.length <= this.capacity &&
    this.capacity > 0 && this.length <= len(this.content) 
    // 0 < |get_content(this.content, 0, this.length)| && |get_content(this.content, 0, this.length)| == this.length && 
    // forall i:Int :: 0 <= i && i < this.length ==> get_content(this.content, 0, this.length)[i] == lookup(this.content, i) 
}

// PART 2: "Simple" append method
//
// Use the dyn_array predicate you defined to implement a method which appends
// the given value at the end of the dynamic array, assuming the capacity is
// sufficient as a precondition.
method append_nogrow(arr: Ref, val: Int)
    requires dyn_array(arr)
    requires unfolding dyn_array(arr) in arr.length < arr.capacity
    requires acc(time_credit(), 1/1)
    // requires unfolding dyn_array(arr) in forall i:Int :: 0 <= i && i < arr.length ==> get_content(arr.content, 0, arr.length)[i] == lookup(arr.content, i) 
    ensures dyn_array(arr)
    ensures unfolding dyn_array(arr) in arr.length <= arr.capacity
    ensures old(get_capacity(arr)) == get_capacity(arr)
    ensures |get_content_dyn_arr(arr)|== |old(get_content_dyn_arr(arr))|+1
    ensures unfolding dyn_array(arr) in lookup(arr.content, arr.length-1) == val
{
    consume_time_credit()
    unfold dyn_array(arr)

    update(arr.content, arr.length, val)
    arr.length := arr.length + 1

    fold dyn_array(arr)
}

// PART 3: Resize method
//
// Use the dyn_array predicate you defined to implement a method which
// reallocates the given dynamic array, doubling its capacity and copying over
// its original contents.

function get_capacity(arr: Ref): Int 
requires dyn_array(arr)
{
    unfolding dyn_array(arr) in arr.capacity
}
function get_length(arr: Ref): Int 
requires dyn_array(arr)
{
    unfolding dyn_array(arr) in arr.length
}



method grow(arr: Ref)
    returns (new_arr: Ref)
    requires dyn_array(arr)
    requires acc(time_credit(), 1/1)
    ensures dyn_array(new_arr)
    ensures old(get_capacity(arr))*2 == get_capacity(new_arr)
    ensures old(get_length(arr)) == get_length(new_arr)
    ensures |old(get_content_dyn_arr(arr))| == |get_content_dyn_arr(new_arr)|

{
    consume_time_credit()
    unfold dyn_array(arr)

    var new_arr_content : Array 
    alloc(new_arr_content, 2*len(arr.content))
    inhale forall i:Int :: 0 <= i && i < len(arr.content) ==> loc(new_arr_content,i).value == loc(arr.content,i).value

    arr.content := new_arr_content
    arr.capacity := len(new_arr_content)

    fold dyn_array(arr)
    new_arr := arr
}

// PART 4: "Full" append method
//
// Using the previous two methods, implement a method which will append a value
// to the given dynamic array, resizing it first if necessary.
method append(arr: Ref, val: Int)
    returns (new_arr: Ref)
    requires dyn_array(arr)
    requires acc(time_credit(), 3/1)
    ensures dyn_array(new_arr)
{
    consume_time_credit()
    unfold dyn_array(arr)

    if (arr.length == arr.capacity){
        fold dyn_array(arr)
        new_arr := grow(arr)

        append_nogrow(new_arr, val)
    }
    else{
        fold dyn_array(arr)
        new_arr := arr
        append_nogrow(new_arr, val)
    }

}

// PART 5: Amortised time analysis
//
// Using stored time credits, prove that `append` runs in constant time.
